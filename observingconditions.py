
# -*- coding: utf-8 -*-
#
# -----------------------------------------------------------------------------
# observingconditions.py - Alpaca API responders for Observingconditions
#
# Author:   Chrisotpher Baker <netpsec.inc _ at _ GMail> cb
#
# -----------------------------------------------------------------------------
# Based on code from GitHub ASCOMInitiative / AlpycaDevice
# -----------------------------------------------------------------------------
# Edit History:
#   Generated by Python Interface Generator for AlpycaDevice
#
# 2023-07-29   cb   Initial edit
#

from falcon import Request, Response, HTTPBadRequest, before
from logging import Logger
from shr import PropertyResponse, MethodResponse, PreProcessRequest, \
                get_request_field, to_bool
                # Modified by CB in order to compile
                # get_request_field, to_bool, to_int, to_float
from exceptions import *        # Nothing but exception classes
from observingconditionsdevice import ObservingConditionsDevice, SensorOptionalFunct

logger: Logger = None

# ----------------------
# MULTI-INSTANCE SUPPORT
# ----------------------
# If this is > 0 then it means that multiple devices of this type are supported.
# Each responder on_get() and on_put() is called with a devnum parameter to indicate
# which instance of the device (0-based) is being called by the client. Leave this
# set to 0 for the simple case of controlling only one instance of this device type.
#
maxdev = 0                      # Single instance

# -----------
# DEVICE INFO
# -----------
# Static metadata not subject to configuration changes
## EDIT FOR YOUR DEVICE ##
class ObservingconditionsMetadata:
    """ Metadata describing the Observingconditions Device. Edit for your device"""
    Name = 'ObservingConditionsFile'
    Version = '0.2'
    Description = 'ObservingConditions from File'
    DeviceType = 'ObservingConditions'
    DeviceID = '658DF341-22CB-48FC-BD7C-A890ED773B30' # https://guidgenerator.com/online-guid-generator.aspx
    #Info = 'Alpaca ObservingConditions Device\nImplements IObservingconditions from a File\nBased on ASCOM Initiative AlpycaDevice'
    Info = 'Alpaca Sample Device\nImplements Observing Conditions\nASCOM Initiative'
    MaxDeviceNumber = maxdev
    InterfaceVersion = 1 # IObservingconditionsVxxx
    #https://ascom-standards.org/Help/Platform/html/N_ASCOM_DeviceInterface.htm

# --------------------------------------------
# Device ObservingConditions () - From a File
# --------------------------------------------
obscond_dev = None
# At app init not import :-)
def start_obscond_device(logger: logger):
    logger = logger
    global obscond_dev
    obscond_dev = ObservingConditionsDevice(logger)


# --------------------
# RESOURCE CONTROLLERS
# --------------------

@before(PreProcessRequest(maxdev))
class Action:
    def on_put(self, req: Request, resp: Response, devnum: int):
        resp.text = MethodResponse(req, NotImplementedException()).json

@before(PreProcessRequest(maxdev))
class CommandBlind:
    def on_put(self, req: Request, resp: Response, devnum: int):
        resp.text = MethodResponse(req, NotImplementedException()).json

@before(PreProcessRequest(maxdev))
class CommandBool:
    def on_put(self, req: Request, resp: Response, devnum: int):
        resp.text = MethodResponse(req, NotImplementedException()).json

@before(PreProcessRequest(maxdev))
class CommandString():
    def on_put(self, req: Request, resp: Response, devnum: int):
        resp.text = MethodResponse(req, NotImplementedException()).json

@before(PreProcessRequest(maxdev))
class Description():
    def on_get(self, req: Request, resp: Response, devnum: int):
        resp.text = PropertyResponse(ObservingconditionsMetadata.Description, req).json

@before(PreProcessRequest(maxdev))
class DriverInfo():
    def on_get(self, req: Request, resp: Response, devnum: int):
        resp.text = PropertyResponse(ObservingconditionsMetadata.Info, req).json

@before(PreProcessRequest(maxdev))
class InterfaceVersion():
    def on_get(self, req: Request, resp: Response, devnum: int):
        resp.text = PropertyResponse(ObservingconditionsMetadata.InterfaceVersion, req).json

@before(PreProcessRequest(maxdev))
class DriverVersion():
    def on_get(self, req: Request, resp: Response, devnum: int):
        resp.text = PropertyResponse(ObservingconditionsMetadata.Version, req).json

@before(PreProcessRequest(maxdev))
class Name():
    def on_get(self, req: Request, resp: Response, devnum: int):
        resp.text = PropertyResponse(ObservingconditionsMetadata.Name, req).json

@before(PreProcessRequest(maxdev))
class SupportedActions():
    # 
    # NEED TO DYNAMICALLY CREATE THIS ... TODO #
    #
    def on_get(self, req: Request, resp: Response, devnum: int):
        resp.text = PropertyResponse(["CloudCover", "DewPoint", "Humidity", "RainRate", "SkyTemperature", "Temperature", "WindSpeed"], req).json  # Not PropertyNotImplemented

# ADDED BY CB - CLASS COPIED FROM ROTATOR EXAMPLE
@before(PreProcessRequest(maxdev))
class connected:
    """Retrieves or sets the connected state of the device

    * Set True to connect to the device hardware. Set False to disconnect
      from the device hardware. Client can also read the property to check
      whether it is connected. This reports the current hardware state.
    * Multiple calls setting Connected to true or false must not cause
      an error.

    """
    def on_get(self, req: Request, resp: Response, devnum: int):
        # resp.text = PropertyResponse(True, req).json
        resp.text = PropertyResponse(obscond_dev.connected, req).json

    def on_put(self, req: Request, resp: Response, devnum: int):
        conn_str = get_request_field('Connected', req)
        conn = to_bool(conn_str)              # Raises 400 Bad Request if str to bool fails

        try:
            # ----------------------
            obscond_dev.connected = conn
            # ----------------------
            resp.text = MethodResponse(req).json
        except Exception as ex:
            resp.text = MethodResponse(req, # Put is actually like a method :-(
                            DriverException(0x500, f'{self.__class__.__name__} failed', ex)).json




@before(PreProcessRequest(maxdev))
class averageperiod:

    def on_get(self, req: Request, resp: Response, devnum: int):
        if not obscond_dev.connected: ##IS DEV CONNECTED##
            resp.text = PropertyResponse(None, req,
                            NotConnectedException()).json
            return
        try:
            # ----------------------
            # Required: MANDATORY
            # Type: Double
            # Description: 
            # Gets and sets the time period (hours) over which observations will be averaged.
            # This property should return the time period (hours) over which sensor readings will be averaged. 
            # If your driver is delivering instantaneous sensor readings this property should return a value of 0.0.
            # ----------------------
            val = 0.25 ## GET PROPERTY ##
            
            resp.text = PropertyResponse(val, req).json
        except Exception as ex:
            resp.text = PropertyResponse(None, req,
                            DriverException(0x500, 'Observingconditions.Averageperiod failed', ex)).json

    def on_put(self, req: Request, resp: Response, devnum: int):
        
        logger.debug('[Averageperiod On_put]')
        
        if not obscond_dev.connected: ## IS DEV CONNECTED ##
            resp.text = PropertyResponse(None, req,
                            NotConnectedException()).json
            return
        averageperiodstr = get_request_field('AveragePeriod', req)      # Raises 400 bad request if missing
        try:
            averageperiod = float(averageperiodstr)
        
        except:
            resp.text = MethodResponse(req,
                            InvalidValueException(f'AveragePeriod " + averageperiodstr + " not a valid number.')).json
            return

        ### RANGE CHECK AS NEEDED ###       # Raise Alpaca InvalidValueException with details!
        # Value can't be negative
        logger.debug(f'[Averageperiodstr: {str(averageperiod)}]')
        if averageperiod < 0:
            resp.text = MethodResponse(req,
                         InvalidValueException(f'AveragePeriod cannot be a negative number.')).json
            return
        
        try:
            # -----------------------------
            ### DEVICE OPERATION(PARAM) ###
            # -----------------------------
            resp.text = MethodResponse(req).json
        except Exception as ex:
            resp.text = MethodResponse(req,
                            DriverException(0x500, 'Observingconditions.Averageperiod failed', ex)).json

@before(PreProcessRequest(maxdev))
class cloudcover:

    def on_get(self, req: Request, resp: Response, devnum: int):
        if not obscond_dev.connected: ##IS DEV CONNECTED##
            resp.text = PropertyResponse(None, req,
                            NotConnectedException()).json
            return
        try:
            # ----------------------
            # Required: OPTIONAL (Can throw a PropertyNotImplementedException)
            # Type: Double
            # Description: 
            # Amount of sky obscured by cloud. (Percentage of the sky covered by clouds.)
            # This property should return a value between 0.0 and 100.0 where 0.0 = clear sky and 100.0 = 100% cloud coverage.
            # ----------------------

            #resp.text = PropertyResponse(val, req).json
            #resp.text = PropertyResponse(req, NotImplementedException()).json
            if Config.sensor_cloud_avail:
                # Sensor is Implemented, Get a value
                # val = 35  ##TEST DATA - TODO ##
                obscond_data = obscond_dev.readobscondfile
                if obscond_data is not None:
                    # Access the CloudFlag from the data dictionary (1 = clear, 2 = light clouds, 3 = very cloudy)
                    cloud_flag = obscond_data.get('CloudFlag')
                    logger.debug(f'[CloudCover On_Get: CloudCover from weather station value: {cloud_flag}.]')
                    if cloud_flag == "1":
                        val = 0 # Expecting a double not string
                    elif cloud_flag == "2":
                        val = 25 
                    elif cloud_flag == "3":
                        val = 100
                    else:
                        # Outside weather station values
                        resp.text = PropertyResponse(None, req,
                                    DriverException(0x500, 'Observingconditions.Cloudcover failed')).json
                        return
                logger.debug(f'[CloudCover On_Get: CloudCover is implemented with a value: {str(val)}.]')
                resp.text = PropertyResponse(val, req).json
            else:
                logger.debug(f'[CloudCover On_Get: CloudCover not implemented.]')
                resp.text = PropertyResponse(None, req,
                            NotImplementedException('Observingconditions.CloudCover not implemented in this driver.')).json
                return

        except Exception as ex:
            resp.text = PropertyResponse(None, req,
                            DriverException(0x500, 'Observingconditions.Cloudcover failed', ex)).json

@before(PreProcessRequest(maxdev))
class dewpoint:

    def on_get(self, req: Request, resp: Response, devnum: int):
        if not obscond_dev.connected: ##IS DEV CONNECTED##
            resp.text = PropertyResponse(None, req,
                            NotConnectedException()).json
            return
        try:
            # ----------------------
            # Required: OPTIONAL  (Can throw a PropertyNotImplementedException)
            # FYI: (Both Humidity + Dewpoint must be implemented or not implemented.  No mixing.)
            # Type: Double
            # Description: 
            # Atmospheric dew point at the observatory. (Atmospheric dew point reported in °C.)
            # The units of this property are degrees Celsius. 
            # Driver and application authors can use the ConvertUnits(Double, Units, Units) method to convert these units to and from degrees Fahrenheit.
            # This property should return a value between 0.0 and 100.0 where 0.0 = 0% relative humidity and 100.0 = 100% relative humidity.
            # ----------------------
            if Config.sensor_dew_avail:
                obscond_data = obscond_dev.readobscondfile
                if obscond_data is not None:
                    # Access the DewPoint from the data dictionary (Imported as a string, Should be temp in whatever degree scale is.)
                    data_dewpoint = float(obscond_data.get('DewPoint')) # Expecting a double not string
                    data_degree_scale = obscond_data.get('TempScale')
                    logger.debug(f'[DewPoint On_Get: DewPoint from weather station value: {str(data_dewpoint)} {data_degree_scale}.]')
                    if data_degree_scale == "C":
                        val = data_dewpoint
                    else:
                        # output the temp after converting to C
                        val = round(((data_dewpoint - 32) * 5/9), 1)
                logger.debug(f'[DewPoint On_Get: DewPoint is implemented with a value: {str(val)} C.]')
                resp.text = PropertyResponse(val, req).json
            else:
                logger.debug(f'[DewPoint On_Get: DewPoint not implemented.]')
                resp.text = PropertyResponse(None, req,
                            NotImplementedException('Observingconditions.DewPoint not implemented in this driver.')).json
                return
                
        except Exception as ex:
            resp.text = PropertyResponse(None, req,
                            DriverException(0x500, 'Observingconditions.Dewpoint failed', ex)).json

@before(PreProcessRequest(maxdev))
class humidity:

    def on_get(self, req: Request, resp: Response, devnum: int):
        if not obscond_dev.connected: ##IS DEV CONNECTED##
            resp.text = PropertyResponse(None, req,
                            NotConnectedException()).json
            return
        try:
            # ----------------------
            # Required: OPTIONAL (Can throw a PropertyNotImplementedException)
            # FYI: (Both Humidity + Dewpoint must be implemented or not implemented.  No mixing.)
            # Type: Double
            # Description:
            # Atmospheric humidity at the observatory.
            # Atmospheric humidity (%)
            # The Utilities component contains methods (DewPoint2Humidity(Double, Double) and 
            # Humidity2DewPoint(Double, Double)) to convert DewPoint to Humidity and vice versa given the ambient temperature.
            # ----------------------
            if Config.sensor_dew_avail:
                obscond_data = obscond_dev.readobscondfile
                if obscond_data is not None:
                    # Access the Humidity from the data dictionary (Imported as a string, Should be percent.)
                    data_humidity = float(obscond_data.get('Humidity'))  # Expecting a double not string
                    logger.debug(f'[Humidity On_Get: Humidity from weather station value: {str(data_humidity)} %.]')
                    val = data_humidity
                logger.debug(f'[Humidity On_Get: Humidity is implemented with a value: {str(val)} %.]')
                resp.text = PropertyResponse(val, req).json
            else:
                logger.debug(f'[Humidity On_Get: Humidity not implemented.]')
                resp.text = PropertyResponse(None, req,
                            NotImplementedException('Observingconditions.Humidity not implemented in this driver.')).json
                return
            
        except Exception as ex:
            resp.text = PropertyResponse(None, req,
                            DriverException(0x500, 'Observingconditions.Humidity failed', ex)).json

@before(PreProcessRequest(maxdev))
class pressure:

    def on_get(self, req: Request, resp: Response, devnum: int):
        if not obscond_dev.connected: ##IS DEV CONNECTED##
            resp.text = PropertyResponse(None, req,
                            NotConnectedException()).json
            return
        try:
            # ----------------------
            # Required: OPTIONAL (Can throw a PropertyNotImplementedException)
            # Type: Double
            # Description: Atmospheric pressure at the observatory (hPa).
            # The units of this property are hectoPascals. Client and driver authors can use the method 
            # ConvertUnits(Double, Units, Units) to convert these units to and from milliBar, mm of mercury and inches of mercury.
            # This must be the pressure at the observatory altitude and not the adjusted pressure at sea level. 
            # Please check whether your pressure sensor delivers local observatory pressure or sea level pressure and, 
            # if it returns sea level pressure, adjust this to actual pressure at the observatory's altitude before returning 
            # a value to the client. The ConvertPressure(Double, Double, Double) method can be used to effect this adjustment.
            # ----------------------
            if Config.sensor_pres_avail:
                obscond_data = obscond_dev.readobscondfile
                if obscond_data is not None:
                    # Access the Pressure from the data dictionary (Imported as a string, Should be pressure in hPa.)
                    # NOT IN MY DATA - data_pressure = float(obscond_data.get('Pressure'))  # Expecting a double not string
                    data_pressure = 0  # SHOULD NOT GET HERE IF CONFIG.TOML CORRECT - DUMMY VALUE #
                    logger.debug(f'[Pressure On_Get: Pressure from weather station value: {str(data_pressure)} hPa.]')
                    val = data_pressure
                    
                logger.debug(f'[Pressure On_Get: Pressure is implemented with a value: {str(val)} hPa.]')
                resp.text = PropertyResponse(val, req).json
            else:
                logger.debug(f'[Pressure On_Get: Pressure not implemented.]')
                resp.text = PropertyResponse(None, req,
                            NotImplementedException('Observingconditions.Pressure not implemented in this driver.')).json
                return
                
        except Exception as ex:
            resp.text = PropertyResponse(None, req,
                            DriverException(0x500, 'Observingconditions.Pressure failed', ex)).json

@before(PreProcessRequest(maxdev))
class rainrate:

    def on_get(self, req: Request, resp: Response, devnum: int):
        if not obscond_dev.connected: ##IS DEV CONNECTED##
            resp.text = PropertyResponse(None, req,
                            NotConnectedException()).json
            return
        try:
            # ----------------------
            # Required: OPTIONAL (Can throw a PropertyNotImplementedException)
            # Type: Double
            # Description: Rain rate at the observatory (mm/hr).
            # The units of this property are millimetres per hour. Client and driver authors can use the 
            # method ConvertUnits(Double, Units, Units) to convert these units to and from inches per hour.
            # This property can be interpreted as 0.0 = Dry any positive non-zero value = wet.
            # Rainfall intensity is classified according to the rate of precipitation:
            # * Light rain — when the precipitation rate is < 2.5 mm (0.098 in) per hour
            # * Moderate rain — when the precipitation rate is between 2.5 mm (0.098 in) - 7.6 mm (0.30 in) or 10 mm (0.39 in) per hour
            # * Heavy rain — when the precipitation rate is > 7.6 mm (0.30 in) per hour, or between 10 mm (0.39 in) and 50 mm (2.0 in) per hour
            # * Violent rain — when the precipitation rate is > 50 mm (2.0 in) per hour
            # ----------------------
            if Config.sensor_rain_avail:
                # Sensor is Implemented, Get a value
                # val = 35  ##TEST DATA - TODO ##
                obscond_data = obscond_dev.readobscondfile
                if obscond_data is not None:
                    # Access the RainFlag from the data dictionary (Weather Station has 1 = dry, 2 = damp, 3 = rain)
                    rain_flag = obscond_data.get('RainFlag')
                    logger.debug(f'[Rainrate On_Get: RainFlag from weather station value: {rain_flag}.]')
                    if rain_flag == "0":
                        val = 0.0
                    elif rain_flag == "1":
                        val = 2.0 # Expecting a double not string
                    elif rain_flag == "2":
                        val = 5.0 
                    elif rain_flag == "3":
                        val = 10.0
                    else:
                        # Outside weather station values
                        resp.text = PropertyResponse(None, req,
                                    DriverException(0x500, 'Observingconditions.RainRate failed')).json
                        return
                logger.debug(f'[RainRate On_Get: RainRate is implemented with a value: {str(val)}.]')
                resp.text = PropertyResponse(val, req).json
            else:
                logger.debug(f'[RainRate On_Get: RainRate not implemented.]')
                resp.text = PropertyResponse(None, req,
                            NotImplementedException('Observingconditions.RainRate not implemented in this driver.')).json
                return
                
        except Exception as ex:
            resp.text = PropertyResponse(None, req,
                            DriverException(0x500, 'Observingconditions.RainRate failed', ex)).json

@before(PreProcessRequest(maxdev))
class skybrightness:

    def on_get(self, req: Request, resp: Response, devnum: int):
        if not obscond_dev.connected: ##IS DEV CONNECTED##
            resp.text = PropertyResponse(None, req,
                            NotConnectedException()).json
            return
        try:
            # ----------------------
            # Required: OPTIONAL (Can throw a PropertyNotImplementedException)
            # Type: Double
            # Description: Sky brightness at the observatory (Lux).
            # This property returns the sky brightness measured in Lux.
            # Luminance Examples in Lux
            # * 0.0001 lux - Moonless, overcast night sky (starlight)
            # * 0.002 lux - Moonless clear night sky with air glow
            # * 0.27–1.0 lux - Full moon on a clear night
            # ----------------------
            if Config.sensor_skyb_avail:
                obscond_data = obscond_dev.readobscondfile
                if obscond_data is not None:
                    # Access the SkyBrightness from the data dictionary (Imported as a string, Should be pressure in Lux.)
                    # NOT IN MY DATA - data_skyb = float(obscond_data.get('SkyB'))  # Expecting a double not string
                    data_skyb = 0 # SHOULD NOT GET HERE IF CONFIG.TOML CORRECT - DUMMY VALUE #
                    logger.debug(f'[SkyBrightness On_Get: SkyBrightness from weather station value: {str(data_skyb)} Lux.]')
                    val = data_skyb
                    
                logger.debug(f'[SkyBrightness On_Get: SkyBrightness is implemented with a value: {str(val)} Lux.]')
                resp.text = PropertyResponse(val, req).json
            else:
                logger.debug(f'[SkyBrightness On_Get: SkyBrightness not implemented.]')
                resp.text = PropertyResponse(None, req,
                            NotImplementedException('Observingconditions.SkyBrightness not implemented in this driver.')).json
                return
                
        except Exception as ex:
            resp.text = PropertyResponse(None, req,
                            DriverException(0x500, 'Observingconditions.SkyBrightness failed', ex)).json

@before(PreProcessRequest(maxdev))
class skyquality:

    def on_get(self, req: Request, resp: Response, devnum: int):
        if not obscond_dev.connected: ##IS DEV CONNECTED##
            resp.text = PropertyResponse(None, req,
                            NotConnectedException()).json
            return
        try:
            # ----------------------
            # Required: OPTIONAL (Can throw a PropertyNotImplementedException)
            # Type: Double
            # Description: 
            # Sky quality at the observatory(mag/sq arcsec)
            # Bortle 1 ~ 22.00 - 21.75
            # Bortle 2 ~ 21.75 - 21.60
            # Bortle 3 ~ 21.60 - 21.30
            # Bortle 4 ~ 21.30 - 20.80
            # Bortle 5 ...
            # ----------------------
            if Config.sensor_skyq_avail:
                obscond_data = obscond_dev.readobscondfile
                if obscond_data is not None:
                    # Access the SkyQuality from the data dictionary (Imported as a string, Should be pressure in mag/sq arcsec.)
                    # NOT IN MY DATA - data_skyq = float(obscond_data.get('SkyQ'))  # Expecting a double not string
                    data_skyq = 0 # SHOULD NOT GET HERE IF CONFIG.TOML CORRECT - DUMMY VALUE #
                    logger.debug(f'[SkyQuality On_Get: SkyQuality from weather station value: {str(data_skyq)} mag/sq arcsec.]')
                    val = data_skyq
                    
                logger.debug(f'[SkyQuality On_Get: SkyQuality is implemented with a value: {str(val)} Lux.]')
                resp.text = PropertyResponse(val, req).json
            else:
                logger.debug(f'[SkyQuality On_Get: SkyQuality not implemented.]')
                resp.text = PropertyResponse(None, req,
                            NotImplementedException('Observingconditions.SkyQuality not implemented in this driver.')).json
                return
            
        except Exception as ex:
            resp.text = PropertyResponse(None, req,
                            DriverException(0x500, 'Observingconditions.SkyQuality failed', ex)).json

@before(PreProcessRequest(maxdev))
class skytemperature:

    def on_get(self, req: Request, resp: Response, devnum: int):
        if not obscond_dev.connected: ##IS DEV CONNECTED##
            resp.text = PropertyResponse(None, req,
                            NotConnectedException()).json
            return
        try:
            # ----------------------
            # Required: OPTIONAL (Can throw a PropertyNotImplementedException)
            # Type: Double
            # Description: Sky temperature at the observatory (deg C)
            # The units of this property are degrees Celsius. Driver and application authors can use the 
            # ConvertUnits(Double, Units, Units) method to convert these units to and from degrees Fahrenheit.
            # This is expected to be returned by an infra-red sensor looking at the sky. The lower the 
            # temperature the more the sky is likely to be clear.
            # ----------------------
            if Config.sensor_skyt_avail:
                obscond_data = obscond_dev.readobscondfile
                if obscond_data is not None:
                    # Access the SkyTemp from the data dictionary (Imported as a string, Should be in dictionary TempScale.)
                    data_skyt = float(obscond_data.get('SkyTemp'))  # Expecting a double not string
                    data_degree_scale = obscond_data.get('TempScale')
                    logger.debug(f'[SkyTemperature On_Get: SkyTemperature from weather station value: {str(data_skyt)} {data_degree_scale}.]')
                    if data_degree_scale == "C":
                        val = data_skyt
                    else:
                        # output the temp after converting to C
                        val = round(((data_skyt - 32) * 5/9), 1)
                logger.debug(f'[SkyTemperature On_Get: SkyTemperature is implemented with a value: {str(val)} C.]')
                resp.text = PropertyResponse(val, req).json
            else:
                logger.debug(f'[SkyTemperature On_Get: SkyTemperature not implemented.]')
                resp.text = PropertyResponse(None, req,
                            NotImplementedException('Observingconditions.SkyTemperature not implemented in this driver.')).json
                return
                
        except Exception as ex:
            resp.text = PropertyResponse(None, req,
                            DriverException(0x500, 'Observingconditions.SkyTemperature failed', ex)).json

@before(PreProcessRequest(maxdev))
class starfwhm:

    def on_get(self, req: Request, resp: Response, devnum: int):
        if not obscond_dev.connected: ##IS DEV CONNECTED##
            resp.text = PropertyResponse(None, req,
                            NotConnectedException()).json
            return
        try:
            # ----------------------
            # Required: OPTIONAL (Can throw a PropertyNotImplementedException)
            # Type: Double
            # Description: 
            # Seeing at the observatory measured as the average star full width half maximum (FWHM in arc secs) within a star field.
            # ----------------------
            if Config.sensor_star_avail:
                obscond_data = obscond_dev.readobscondfile
                if obscond_data is not None:
                    # Access the SkyQuality from the data dictionary (Imported as a string, Should be pressure in mag/sq arcsec.)
                    # NOT IN MY DATA - data_starfwhm = float(obscond_data.get('StarFWHM'))  # Expecting a double not string
                    data_starfwhm = 0 # SHOULD NOT GET HERE IF CONFIG.TOML CORRECT - DUMMY VALUE #
                    logger.debug(f'[StarFWHM On_Get: StarFWHM from weather station value: {str(data_starfwhm)} arcsec.]')
                    val = data_starfwhm
                    
                logger.debug(f'[StarFWHM On_Get: StarFWHM is implemented with a value: {str(val)} arcsec.]')
                resp.text = PropertyResponse(val, req).json
            else:
                logger.debug(f'[StarFWHM On_Get: StarFWHM not implemented.]')
                resp.text = PropertyResponse(None, req,
                            NotImplementedException('Observingconditions.StarFWHM not implemented in this driver.')).json
                return
                
        except Exception as ex:
            resp.text = PropertyResponse(None, req,
                            DriverException(0x500, 'Observingconditions.StarFWHM failed', ex)).json

@before(PreProcessRequest(maxdev))
class temperature:

    def on_get(self, req: Request, resp: Response, devnum: int):
        if not obscond_dev.connected: ##IS DEV CONNECTED##
            resp.text = PropertyResponse(None, req,
                            NotConnectedException()).json
            return
        try:
            # ----------------------
            # Required: OPTIONAL (Can throw a PropertyNotImplementedException)
            # Type: Double
            # Description: Temperature at the observatory (deg C).  The units of this property are degrees Celsius. 
            # Driver and application authors can use the ConvertUnits(Double, Units, Units) method to convert 
            # these units to and from degrees Fahrenheit. 
            # This is expected to be the ambient temperature at the observatory.
            # ----------------------
            if Config.sensor_temp_avail:
                obscond_data = obscond_dev.readobscondfile
                if obscond_data is not None:
                    # Access the Ambient Temperature from the data dictionary (Imported as a string, Should be in dictionary TempScale.)
                    data_temp = float(obscond_data.get('AmbientTemp'))  # Expecting a double not string
                    data_degree_scale = obscond_data.get('TempScale')
                    logger.debug(f'[Temperature On_Get: Temperature from weather station value: {str(data_temp)} {data_degree_scale}.]')
                    if data_degree_scale == "C":
                        val = data_temp
                    else:
                        # output the temp after converting to C
                        val = round(((data_temp - 32) * 5/9), 1)
                logger.debug(f'[Temperature On_Get: Temperature is implemented with a value: {str(val)} C.]')
                resp.text = PropertyResponse(val, req).json
            else:
                logger.debug(f'[Temperature On_Get: Temperature not implemented.]')
                resp.text = PropertyResponse(None, req,
                            NotImplementedException('Observingconditions.Temperature not implemented in this driver.')).json
                return
                
        except Exception as ex:
            resp.text = PropertyResponse(None, req,
                            DriverException(0x500, 'Observingconditions.Temperature failed', ex)).json

@before(PreProcessRequest(maxdev))
class winddirection:

    def on_get(self, req: Request, resp: Response, devnum: int):
        if not obscond_dev.connected: ##IS DEV CONNECTED##
            resp.text = PropertyResponse(None, req,
                            NotConnectedException()).json
            return
        try:
            # ----------------------
            # Required: OPTIONAL (Can throw a PropertyNotImplementedException)
            # Type: Double
            # Description: Wind direction at the observatory (degrees, 0..360.0).
            # The returned value must be between 0.0 and 360.0, interpreted according to the meteorological 
            # standard, where a special value of 0.0 is returned when the wind speed is 0.0. 
            # Wind direction is measured clockwise from north, through east, where East=90.0, South=180.0, West=270.0 and North=360.0.
            # ----------------------
            if Config.sensor_windd_avail:
                obscond_data = obscond_dev.readobscondfile
                if obscond_data is not None:
                    # Access the WindDir from the data dictionary (Imported as a string, Should be in dictionary at degrees.)
                    # NOT IN MY DATA - data_winddir = float(obscond_data.get('WindDir'))  # Expecting a double not string
                    data_winddir = 0 # SHOULD NOT GET HERE IF CONFIG.TOML CORRECT - DUMMY VALUE #
                    logger.debug(f'[WindDirection On_Get: WindDirection from weather station value: {str(data_winddir)} degree.]')
                    val = data_winddir
                logger.debug(f'[WinDirection On_Get: WindDirection is implemented with a value: {str(val)} degrees.]')
                resp.text = PropertyResponse(val, req).json
            else:
                logger.debug(f'[WindDirection On_Get: WindDirection not implemented.]')
                resp.text = PropertyResponse(None, req,
                            NotImplementedException('Observingconditions.WindDirection not implemented in this driver.')).json
                return
                
        except Exception as ex:
            resp.text = PropertyResponse(None, req,
                            DriverException(0x500, 'Observingconditions.WindDirection failed', ex)).json

@before(PreProcessRequest(maxdev))
class windgust:

    def on_get(self, req: Request, resp: Response, devnum: int):
        if not obscond_dev.connected: ##IS DEV CONNECTED##
            resp.text = PropertyResponse(None, req,
                            NotConnectedException()).json
            return
        try:
            # ----------------------
            # Required: OPTIONAL (Can throw a PropertyNotImplementedException)
            # Type: Double
            # Description: Peak 3 second wind gust at the observatory over the last 2 minutes (m/s). 
            # Driver and application authors can use the ConvertUnits(Double, Units, Units) method to 
            # convert these units to and from miles per hour or knots.
            # ----------------------
            if Config.sensor_windg_avail:
                obscond_data = obscond_dev.readobscondfile
                if obscond_data is not None:
                    # Access the WindDir from the data dictionary (Imported as a string, Should be in dictionary at m/s.)
                    # NOT IN MY DATA - data_winddir = float(obscond_data.get('WindDir'))  # Expecting a double not string
                    data_windgust = 0 # SHOULD NOT GET HERE IF CONFIG.TOML CORRECT - DUMMY VALUE #
                    logger.debug(f'[WindGust On_Get: WindGust from weather station value: {str(data_windgust)} m/s.]')
                    val = data_windgust
                    resp.text = PropertyResponse(val, req).json
            else:
                logger.debug(f'[WindGust On_Get: WindGust not implemented.]')
                resp.text = PropertyResponse(None, req,
                            NotImplementedException('Observingconditions.WindGust not implemented in this driver.')).json
                return
                
        except Exception as ex:
            resp.text = PropertyResponse(None, req,
                            DriverException(0x500, 'Observingconditions.WindGust failed', ex)).json

@before(PreProcessRequest(maxdev))
class windspeed:

    def on_get(self, req: Request, resp: Response, devnum: int):
        if not obscond_dev.connected: ##IS DEV CONNECTED##
            resp.text = PropertyResponse(None, req,
                            NotConnectedException()).json
            return
        try:
            # ----------------------
            # Required: OPTIONAL (Can throw a PropertyNotImplementedException)
            # Type: Double
            # Description: Wind speed at the observatory (m/s). Driver and application authors can use the 
            # ConvertUnits(Double, Units, Units) method to convert these units to and from miles per hour or knots.
            # ----------------------
            if Config.sensor_winds_avail:
                obscond_data = obscond_dev.readobscondfile
                if obscond_data is not None:
                    # Access the Wind Speed from the data dictionary (Imported as a string, Should be in dictionary WindScale.)
                    data_windspeed = float(obscond_data.get('WindSpeed'))  # Expecting a double not string
                    data_wind_scale = obscond_data.get('WindScale')
                    if data_wind_scale == "M":
                        data_wind_scale_full = "mph"
                    elif data_wind_scale == "K":
                        data_wind_scale_full = "knots"
                    else:
                        data_wind_scale_full = data_wind_scale
                    logger.debug(f'[WindSpeed On_Get: WindSpeed from weather station value: {str(data_windspeed)} {data_wind_scale_full}.]')
                    if data_wind_scale == "M":
                        # Output the windspeed as meters/sec from mph
                        val = round((data_windspeed * 0.44704), 0)
                    else:
                        # output the windspeed as meters/sec from knots
                        val = round((data_windspeed * 0.514444), 0)
                logger.debug(f'[WindSpeed On_Get: WindSpeed is implemented with a value: {str(val)} meters/sec.]')
                resp.text = PropertyResponse(val, req).json
            else:
                logger.debug(f'[WindSpeed On_Get: WindSpeed not implemented.')
                resp.text = PropertyResponse(None, req,
                            NotImplementedException('Observingconditions.WindSpeed not implemented in this driver.')).json
                return
                
        except Exception as ex:
            resp.text = PropertyResponse(None, req,
                            DriverException(0x500, 'Observingconditions.WindSpeed failed', ex)).json

@before(PreProcessRequest(maxdev))
class refresh:

    def on_put(self, req: Request, resp: Response, devnum: int):
        if not obscond_dev.connected: ## IS DEV CONNECTED ##
            resp.text = PropertyResponse(None, req,
                            NotConnectedException()).json
            return
        try:
            # ----------------------
            # Required: OPTIONAL (NOT CLEAR!)
            # FYI: This is a Method ???
            # Type: NONE
            # Description: 
            # Forces the driver to immediately query its attached hardware to refresh sensor values
            # -----------------------------
            ### DEVICE OPERATION(PARAM) ###
            resp.text = MethodResponse(req).json
            
        except Exception as ex:
            resp.text = MethodResponse(req,
                            DriverException(0x500, 'Observingconditions.Refresh failed', ex)).json

@before(PreProcessRequest(maxdev))
class sensordescription:

    def on_get(self, req: Request, resp: Response, devnum: int):
        if not obscond_dev.connected: ##IS DEV CONNECTED##
            resp.text = PropertyResponse(None, req,
                            NotConnectedException()).json
            return
        
        try:
            # ----------------------
            # Required: MANDATORY (NOT CLEAR)
            # FYI: THIS IS A METHOD??
            # Type: String
            # Description: 
            # Provides a description of the sensor providing the requested property. 
            # CONDITIONS:
            # PropertyName must be the name of one of the sensor properties specified in the 
            # IObservingConditions interface. If the caller supplies some other value, throw an InvalidValueException.
            # If the sensor is implemented, this must return a valid string, even if the driver is not connected, 
            # so that applications can use this to determine what sensors are available.
            # If the sensor is not implemented, this must throw a MethodNotImplementedException.
            # ----------------------
            
            sensorname_str = get_request_field('SensorName', req)      # Raises 400 bad request if missing
            try:
                # Test
                logger.debug(f'[SensorDescription On_Get]')
            
            except:
                resp.text = MethodResponse(req,
                                InvalidValueException(f'SensorName not a valid sensor.')).json
                return
            

            # Debug Logging
            logger.debug(f'[SensorDescription On_Get: Request = {sensorname_str}.]')

            # Test if the sensor feature is valid, enabled, and only return those enabled
            # Is sensorname requested valid?
            if sensorname_str in SensorOptionalFunct.sensor_functions:
                #Sensor Name is valid
                if SensorOptionalFunct.sensor_functions[sensorname_str]:
                    # sensor name is implemented
                    # Return last time the file was read
                    val =   SensorOptionalFunct.sensor_descriptions[sensorname_str]
                    logger.debug(f'[SensorDescription: {sensorname_str} is implemented with value: {val}.]')
                    resp.text = PropertyResponse(val, req).json
                    return
                else:
                     # Sensor is valid but not implemented
                    logger.debug(f'[SensorDescription: {sensorname_str} not implemented.]')
                    resp.text = PropertyResponse(None, req,
                                                NotImplementedException(f'Observingconditions {sensorname_str} not implemented in this driver.')).json
                    return
            else:
                # Sensor Name is NOT valid so return error
                logger.debug(f'[SensorDescription: Invalid Sensor Name: {sensorname_str}.]')
                resp.text = PropertyResponse(None, req,
                                            InvalidValueException('Invalid SensorName.')).json
                return
                
        except Exception as ex:
            resp.text = PropertyResponse(None, req,
                            DriverException(0x500, 'Observingconditions.Sensordescription failed', ex)).json

@before(PreProcessRequest(maxdev))
class timesincelastupdate:

    def on_get(self, req: Request, resp: Response, devnum: int):
        if not obscond_dev.connected: ##IS DEV CONNECTED##
            resp.text = PropertyResponse(None, req,
                            NotConnectedException()).json
            return
        try:
            # ----------------------
            # Required: MANDATORY
            # Type: Double
            # Description: 
            # Provides the time since the sensor value was last updated (sec). 
            # CONDITIONS:
            # PropertyName must be the name of one of the sensor properties specified in the IObservingConditions interface. 
            # If the caller supplies some other value, throw an InvalidValueException.
            # Return a negative value to indicate that no valid value has ever been received from the hardware.
            # If an empty string is supplied as the PropertyName, the driver must return the time since the most 
            # recent update of any sensor. A MethodNotImplementedException must not be thrown in this circumstance.
            # ----------------------
            sensorname_str = get_request_field('SensorName', req)      # Raises 400 bad request if missing
            try:
                # Test
                logger.debug(f'[TimeSinceLastUpdate: Sensor name: {sensorname_str}]')
            
            except:
                resp.text = MethodResponse(req,
                                InvalidValueException(f'SensorName not a valid sensor.')).json
                return 
 
            obscond_data = obscond_dev.readobscondfile
            if obscond_data is not None:
                # Access the Elapsed Time Since File Write from the data dictionary (Imported as a string, Should be in seconds.)
                #data_file_write_time = float(obscond_data.get('FileWriteTime'))  # Expecting a double not string
                #data_file_write_date = obscond_data.get('FileWriteDate')
                data_file_elapsed_write_time = obscond_data.get('ElapsedTimeLastFileWrite')
                
            if (len(sensorname_str) == 0):
                # If an empty string is supplied as the PropertyName, the driver must return the time since 
                # the most recent update of any sensor. A MethodNotImplementedException must not be thrown in this circumstance.
                val = float(data_file_elapsed_write_time)
                resp.text = PropertyResponse(val, req).json
                logger.debug(f'[TimeSinceLastUpdate: {sensorname_str} (blank so latest of all sensors) is implemented with value: {str(val)} sec.]')
                return
 
            # Test if the sensor feature is valid, enabled, and only return those enabled
            # Is sensorname requested valid?
            if sensorname_str in SensorOptionalFunct.sensor_functions:
                # Sensor name is valid
                if SensorOptionalFunct.sensor_functions[sensorname_str]:
                    # sensor name is implemented too
                    # Return last time the file was read
                    val = float(data_file_elapsed_write_time)
                    resp.text = PropertyResponse(val, req).json
                    logger.debug(f'[TimeSinceLastUpdate: {sensorname_str} is implemented with value: {str(val)}.]')
                    return
                else:
                    # Sensor is valid but not implemented
                    logger.debug(f'[TimeSinceLastUpdate: {sensorname_str} not implemented.]')
                    resp.text = PropertyResponse(None, req,
                                                NotImplementedException(f'Observingconditions {sensorname_str} not implemented in this driver.')).json
                    return
            else:
                # Sensor Name is not valid, so return error
                resp.text = PropertyResponse(None, req,
                                            InvalidValueException('Invalid SensorName.')).json
                return

        except Exception as ex:
            resp.text = PropertyResponse(None, req,
                            DriverException(0x500, 'Observingconditions.Timesincelastupdate failed', ex)).json

